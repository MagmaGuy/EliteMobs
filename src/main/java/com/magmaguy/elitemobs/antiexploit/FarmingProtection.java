package com.magmaguy.elitemobs.antiexploit;

import com.magmaguy.elitemobs.MetadataHandler;
import com.magmaguy.elitemobs.config.AntiExploitConfig;
import com.magmaguy.elitemobs.config.CommandMessagesConfig;
import com.magmaguy.elitemobs.mobconstructor.EliteEntity;
import com.magmaguy.elitemobs.mobconstructor.custombosses.CustomBossEntity;
import com.magmaguy.elitemobs.skills.CombatLevelCalculator;
import com.magmaguy.magmacore.util.ChatColorConverter;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.*;

/**
 * Prevents farming of natural elite mobs by limiting kills per hour.
 * Also limits XP/loot based on level difference between player and mob.
 */
public class FarmingProtection {

    // Configuration constants - could be moved to config file
    private static final int MAX_KILLS_PER_HOUR = 30;
    private static final int EARLY_CAP_KILLS = 10;
    private static final long EARLY_CAP_WINDOW_MS = 10 * 60 * 1000; // 10 minutes
    private static final long HOUR_MS = 60 * 60 * 1000; // 1 hour
    private static final int MAX_LEVEL_DIFFERENCE = 5;

    // Track kills per player: UUID -> list of kill timestamps
    private static final Map<UUID, List<Long>> killTimestamps = new HashMap<>();
    // Track players who are currently capped
    private static final Set<UUID> cappedPlayers = new HashSet<>();
    // Track when each player's cap expires
    private static final Map<UUID, Long> capExpiry = new HashMap<>();

    public static void shutdown() {
        killTimestamps.clear();
        cappedPlayers.clear();
        capExpiry.clear();
    }

    /**
     * Records a natural elite kill and checks if the player is capped.
     *
     * @param player The player who killed the elite
     * @param eliteEntity The elite that was killed
     * @return true if the kill should count (not capped), false if capped
     */
    public static boolean recordNaturalEliteKill(Player player, EliteEntity eliteEntity) {
        if (!AntiExploitConfig.isFarmingProtection()) return true;
        // Only applies to natural spawns, not custom bosses
        if (eliteEntity instanceof CustomBossEntity) return true;

        UUID uuid = player.getUniqueId();
        long now = System.currentTimeMillis();

        // Check if player is currently capped
        if (cappedPlayers.contains(uuid)) {
            Long expiry = capExpiry.get(uuid);
            if (expiry != null && now < expiry) {
                sendCapMessage(player, expiry - now);
                return false;
            } else {
                // Cap expired
                cappedPlayers.remove(uuid);
                capExpiry.remove(uuid);
                killTimestamps.remove(uuid);
            }
        }

        // Get or create kill list for this player
        List<Long> kills = killTimestamps.computeIfAbsent(uuid, k -> new ArrayList<>());

        // Clean up old kills (older than 1 hour)
        kills.removeIf(timestamp -> now - timestamp > HOUR_MS);

        // Add current kill
        kills.add(now);

        // Check for early cap (10 kills in 10 minutes)
        long tenMinutesAgo = now - EARLY_CAP_WINDOW_MS;
        long recentKills = kills.stream().filter(t -> t > tenMinutesAgo).count();
        if (recentKills >= EARLY_CAP_KILLS) {
            applyCap(player, now + HOUR_MS);
            return false;
        }

        // Check for hourly cap
        if (kills.size() >= MAX_KILLS_PER_HOUR) {
            applyCap(player, now + HOUR_MS);
            return false;
        }

        return true;
    }

    private static void applyCap(Player player, long expiryTime) {
        UUID uuid = player.getUniqueId();
        cappedPlayers.add(uuid);
        capExpiry.put(uuid, expiryTime);

        player.sendMessage(ChatColorConverter.convert(
            CommandMessagesConfig.getFarmingWarningMessage()
                .replace("$time", formatTime(expiryTime - System.currentTimeMillis()))
        ));

        // Schedule cap removal
        new BukkitRunnable() {
            @Override
            public void run() {
                cappedPlayers.remove(uuid);
                capExpiry.remove(uuid);
                killTimestamps.remove(uuid);
                if (player.isOnline()) {
                    player.sendMessage(ChatColorConverter.convert(
                        CommandMessagesConfig.getFarmingResetMessage()
                    ));
                }
            }
        }.runTaskLater(MetadataHandler.PLUGIN, (expiryTime - System.currentTimeMillis()) / 50);
    }

    private static void sendCapMessage(Player player, long remainingMs) {
        player.sendMessage(ChatColorConverter.convert(
            CommandMessagesConfig.getFarmingCapMessage()
                .replace("$time", formatTime(remainingMs))
        ));
    }

    private static String formatTime(long ms) {
        long minutes = (ms / 1000) / 60;
        long seconds = (ms / 1000) % 60;
        if (minutes > 0) {
            return minutes + "m " + seconds + "s";
        }
        return seconds + "s";
    }

    /**
     * Checks if a player is currently capped from earning natural elite rewards.
     */
    public static boolean isPlayerCapped(Player player) {
        if (!AntiExploitConfig.isFarmingProtection()) return false;
        UUID uuid = player.getUniqueId();
        if (!cappedPlayers.contains(uuid)) return false;

        Long expiry = capExpiry.get(uuid);
        if (expiry == null || System.currentTimeMillis() >= expiry) {
            cappedPlayers.remove(uuid);
            capExpiry.remove(uuid);
            killTimestamps.remove(uuid);
            return false;
        }
        return true;
    }

    /**
     * Calculates XP multiplier based on level difference.
     * Mobs more than 5 levels higher give XP as if they were only 5 levels higher.
     * Mobs more than 5 levels lower give no XP.
     *
     * @param player The player
     * @param mobLevel The mob's level
     * @return XP multiplier (0.0 to 1.0), or -1 if no XP should be given
     */
    public static double getXPMultiplier(Player player, int mobLevel) {
        if (!AntiExploitConfig.isFarmingProtection()) return 1.0;
        int combatLevel = CombatLevelCalculator.calculateCombatLevel(player.getUniqueId());
        int levelDiff = mobLevel - combatLevel;

        // Mob is too low level - no XP
        if (levelDiff < -MAX_LEVEL_DIFFERENCE) {
            return 0.0;
        }

        // Mob is within range - full XP
        if (levelDiff <= MAX_LEVEL_DIFFERENCE) {
            return 1.0;
        }

        // Mob is too high level - cap the effective level
        // Return ratio of capped level vs actual level
        int cappedMobLevel = combatLevel + MAX_LEVEL_DIFFERENCE;
        return (double) cappedMobLevel / mobLevel;
    }

    /**
     * Gets the effective mob level for XP calculation (capped at +5 of combat level).
     */
    public static int getEffectiveMobLevelForXP(Player player, int mobLevel) {
        if (!AntiExploitConfig.isFarmingProtection()) return mobLevel;
        int combatLevel = CombatLevelCalculator.calculateCombatLevel(player.getUniqueId());
        int maxLevel = combatLevel + MAX_LEVEL_DIFFERENCE;

        if (mobLevel > maxLevel) {
            return maxLevel;
        }
        return mobLevel;
    }

    /**
     * Checks if loot should drop based on level difference.
     * No loot if mob is more than 5 levels below combat level.
     */
    public static boolean shouldDropLoot(Player player, int mobLevel) {
        if (!AntiExploitConfig.isFarmingProtection()) return true;
        int combatLevel = CombatLevelCalculator.calculateCombatLevel(player.getUniqueId());
        int levelDiff = mobLevel - combatLevel;

        // Mob is more than 5 levels below - no loot
        return levelDiff >= -MAX_LEVEL_DIFFERENCE;
    }

    /**
     * Gets how many kills the player has made in the current hour.
     */
    public static int getCurrentHourlyKills(Player player) {
        List<Long> kills = killTimestamps.get(player.getUniqueId());
        if (kills == null) return 0;

        long now = System.currentTimeMillis();
        kills.removeIf(timestamp -> now - timestamp > HOUR_MS);
        return kills.size();
    }
}
